import {
  boolean,
  check,
  integer,
  numeric,
  pgEnum,
  pgTable,
  serial,
  text,
  timestamp,
  varchar,
} from "drizzle-orm/pg-core";
import { sql } from "drizzle-orm";

/**
 * Enums (must be declared before use)
 */
export const userRoleEnum = pgEnum("user_role", ["user", "admin"]);

export const menuItemTypeEnum = pgEnum("menu_item_type", [
  "drink",
  "main_course",
  "dessert",
]);

export const acceptanceStatusEnum = pgEnum("acceptance_status", [
  "pending",
  "accepted",
  "declined",
]);

export const ticketStatusEnum = pgEnum("ticket_status", [
  "open",
  "in_progress",
  "closed",
]);

export const ticketPriorityEnum = pgEnum("ticket_priority", [
  "low",
  "medium",
  "high",
  "urgent",
]);

export const logLevelEnum = pgEnum("log_level", [
  "info",
  "warn",
  "error",
  "debug",
]);

export const menuParseBatchStatusEnum = pgEnum("menu_parse_batch_status", [
  "UPLOADED",
  "PARSING",
  "PARSED",
  "PARSE_FAILED",
  "CHANGES_PROPOSED",
  "APPROVED",
  "PUBLISHING",
  "PUBLISHED",
  "REJECTED",
]);

export const menuParseItemActionEnum = pgEnum("menu_parse_item_action", [
  "PENDING",
  "ACCEPT",
  "EDIT",
  "REJECT",
]);

/**
 * Authentication schema.
 *
 * Generated by better-auth CLI.
 *
 * Only make changes to these tables if you know what you're doing.
 */
export const user = pgTable("user", {
  id: text("id").primaryKey(),
  name: text("name").notNull(),
  email: text("email").notNull().unique(),
  emailVerified: boolean("email_verified").default(false).notNull(),
  image: text("image"),
  role: userRoleEnum("role").default("user").notNull(), // 'user' or 'admin'
  isMasterAdmin: boolean("is_master_admin").default(false).notNull(), // first admin, cannot be demoted
  mustChangePassword: boolean("must_change_password").default(false).notNull(), // force password change on first login
  createdAt: timestamp("created_at", { withTimezone: true })
    .defaultNow()
    .notNull(),
  updatedAt: timestamp("updated_at", { withTimezone: true })
    .defaultNow()
    .$onUpdate(() => new Date())
    .notNull(),
});

export const session = pgTable("session", {
  id: text("id").primaryKey(),
  expiresAt: timestamp("expires_at", { withTimezone: true }).notNull(),
  token: text("token").notNull().unique(),
  createdAt: timestamp("created_at", { withTimezone: true })
    .defaultNow()
    .notNull(),
  updatedAt: timestamp("updated_at", { withTimezone: true })
    .defaultNow()
    .$onUpdate(() => new Date())
    .notNull(),
  ipAddress: text("ip_address"),
  userAgent: text("user_agent"),
  userId: text("user_id")
    .notNull()
    .references(() => user.id, { onDelete: "cascade" }),
});

export const account = pgTable("account", {
  id: text("id").primaryKey(),
  accountId: text("account_id").notNull(),
  providerId: text("provider_id").notNull(),
  userId: text("user_id")
    .notNull()
    .references(() => user.id, { onDelete: "cascade" }),
  accessToken: text("access_token"),
  refreshToken: text("refresh_token"),
  idToken: text("id_token"),
  accessTokenExpiresAt: timestamp("access_token_expires_at", {
    withTimezone: true,
  }),
  refreshTokenExpiresAt: timestamp("refresh_token_expires_at", {
    withTimezone: true,
  }),
  scope: text("scope"),
  password: text("password"),
  createdAt: timestamp("created_at", { withTimezone: true })
    .defaultNow()
    .notNull(),
  updatedAt: timestamp("updated_at", { withTimezone: true })
    .defaultNow()
    .$onUpdate(() => new Date())
    .notNull(),
});

export const verification = pgTable("verification", {
  id: text("id").primaryKey(),
  identifier: text("identifier").notNull(),
  value: text("value").notNull(),
  expiresAt: timestamp("expires_at", { withTimezone: true }).notNull(),
  createdAt: timestamp("created_at", { withTimezone: true })
    .defaultNow()
    .notNull(),
  updatedAt: timestamp("updated_at", { withTimezone: true })
    .defaultNow()
    .$onUpdate(() => new Date())
    .notNull(),
});

/**
 * Below, feel free to delete/update/add tables as you see fit for your app.
 */
export const demoData = pgTable("demo_data", {
  id: serial("id").primaryKey(),
  header: text("header").notNull(),
  type: text("type").notNull(),
  status: text("status").notNull(),
  target: integer("target").notNull(),
  limit: integer("limit").notNull(),
  reviewer: text("reviewer").notNull(),
});

/**
 * Restaurant management schema
 */

// Restaurants table
export const restaurant = pgTable(
  "restaurant",
  {
    id: serial("id").primaryKey(),
    name: text("name").notNull(),
    location: text("location").notNull(),
    tag: text("tag").notNull(), // restaurant type (e.g., Italian, Chinese, etc.)
    phoneNumber: varchar("phone_number", { length: 50 }),
    openingHours: text("opening_hours"), // JSON string or text format
    rating: numeric("rating", { precision: 3, scale: 2 }), // e.g., 4.50
    createdAt: timestamp("created_at", { withTimezone: true })
      .defaultNow()
      .notNull(),
    updatedAt: timestamp("updated_at", { withTimezone: true })
      .defaultNow()
      .$onUpdate(() => new Date())
      .notNull(),
  },
  (table) => [
    check(
      "rating_range",
      sql`${table.rating} IS NULL OR (${table.rating} >= 0 AND ${table.rating} <= 5)`,
    ),
  ],
);

// Menu items (Speisekarte)
export const menuItem = pgTable("menu_item", {
  id: serial("id").primaryKey(),
  restaurantId: integer("restaurant_id")
    .notNull()
    .references(() => restaurant.id, { onDelete: "cascade" }),
  dishName: text("dish_name").notNull(),
  type: menuItemTypeEnum("type").notNull(), // 'drink', 'main_course', 'dessert'
  category: text("category").notNull(), // e.g., 'pasta', 'pizza', 'salad'
  price: numeric("price", { precision: 10, scale: 2 }).notNull(), // price as shown on menu
  givesRefund: boolean("gives_refund").default(false).notNull(), // whether item provides token refund
  createdAt: timestamp("created_at", { withTimezone: true })
    .defaultNow()
    .notNull(),
  updatedAt: timestamp("updated_at", { withTimezone: true })
    .defaultNow()
    .$onUpdate(() => new Date())
    .notNull(),
});

// Token lending (Markenverleih)
// Note: This table tracks lending relationships between users
// Each record represents a lending relationship with a specific person
// Multiple records can exist for the same person (different transactions)
export const tokenLending = pgTable("token_lending", {
  id: serial("id").primaryKey(),
  userId: text("user_id")
    .notNull()
    .references(() => user.id, { onDelete: "cascade" }),
  lendToUserId: text("lend_to_user_id").references(() => user.id, {
    onDelete: "cascade",
  }), // FK to user table - the person tokens are lent to (optional for backwards compatibility)
  personName: text("person_name").notNull(), // name of the person tokens are lent to/borrowed from (display name, can be from user.name or free text)
  tokenCount: integer("token_count").notNull(), // positive = lent, negative = borrowed
  lastLendingDate: timestamp("last_lending_date", { withTimezone: true })
    .defaultNow()
    .notNull(),
  totalTokensLent: integer("total_tokens_lent").default(0).notNull(), // cumulative count across all transactions with this person (maintained by application or trigger)
  acceptanceStatus: acceptanceStatusEnum("acceptance_status")
    .default("pending")
    .notNull(), // 'pending', 'accepted', 'declined'
  version: integer("version").default(1).notNull(), // optimistic locking for concurrency control
  createdAt: timestamp("created_at", { withTimezone: true })
    .defaultNow()
    .notNull(),
  updatedAt: timestamp("updated_at", { withTimezone: true })
    .defaultNow()
    .$onUpdate(() => new Date())
    .notNull(),
});

// Order history
export const orderHistory = pgTable("order_history", {
  id: serial("id").primaryKey(),
  userId: text("user_id")
    .notNull()
    .references(() => user.id, { onDelete: "cascade" }),
  restaurantId: integer("restaurant_id")
    .notNull()
    .references(() => restaurant.id, { onDelete: "cascade" }),
  visitDate: timestamp("visit_date", { withTimezone: true })
    .defaultNow()
    .notNull(),
  totalPrice: numeric("total_price", { precision: 10, scale: 2 }).notNull(), // total order price
  createdAt: timestamp("created_at", { withTimezone: true })
    .defaultNow()
    .notNull(),
});

// Order history items (individual products in an order)
// Note: Uses text instead of enums for historical data preservation
// This allows display of correct values even if menu structure changes
export const orderHistoryItem = pgTable("order_history_item", {
  id: serial("id").primaryKey(),
  orderHistoryId: integer("order_history_id")
    .notNull()
    .references(() => orderHistory.id, { onDelete: "cascade" }),
  dishName: text("dish_name").notNull(), // stored at time of order
  type: text("type").notNull(), // stored at time of order (e.g., 'drink', 'main_course', 'dessert')
  category: text("category").notNull(), // stored at time of order
  price: numeric("price", { precision: 10, scale: 2 }).notNull(), // price at time of order
  createdAt: timestamp("created_at", { withTimezone: true })
    .defaultNow()
    .notNull(),
});

// Favorites (for both restaurants and dishes)
export const favorite = pgTable(
  "favorite",
  {
    id: serial("id").primaryKey(),
    userId: text("user_id")
      .notNull()
      .references(() => user.id, { onDelete: "cascade" }),
    restaurantId: integer("restaurant_id").references(() => restaurant.id, {
      onDelete: "cascade",
    }), // null if favorite is a dish
    menuItemId: integer("menu_item_id").references(() => menuItem.id, {
      onDelete: "cascade",
    }), // null if favorite is a restaurant
    createdAt: timestamp("created_at", { withTimezone: true })
      .defaultNow()
      .notNull(),
  },
  (table) => [
    check(
      "favorite_type_check",
      sql`(${table.restaurantId} IS NOT NULL AND ${table.menuItemId} IS NULL) OR (${table.restaurantId} IS NULL AND ${table.menuItemId} IS NOT NULL)`,
    ),
  ],
);

/**
 * Admin & Support System Schema
 */

// Support tickets
export const ticket = pgTable("ticket", {
  id: serial("id").primaryKey(),
  userId: text("user_id")
    .notNull()
    .references(() => user.id, { onDelete: "cascade" }),
  title: text("title").notNull(),
  description: text("description").notNull(),
  status: ticketStatusEnum("status").default("open").notNull(),
  priority: ticketPriorityEnum("priority").default("medium").notNull(),
  assignedToAdminId: text("assigned_to_admin_id").references(() => user.id, {
    onDelete: "set null",
  }), // admin who is handling the ticket
  closedByAdminId: text("closed_by_admin_id").references(() => user.id, {
    onDelete: "set null",
  }), // admin who closed the ticket
  closedAt: timestamp("closed_at", { withTimezone: true }),
  createdAt: timestamp("created_at", { withTimezone: true })
    .defaultNow()
    .notNull(),
  updatedAt: timestamp("updated_at", { withTimezone: true })
    .defaultNow()
    .$onUpdate(() => new Date())
    .notNull(),
});

// Ticket comments/messages
export const ticketComment = pgTable("ticket_comment", {
  id: serial("id").primaryKey(),
  ticketId: integer("ticket_id")
    .notNull()
    .references(() => ticket.id, { onDelete: "cascade" }),
  userId: text("user_id")
    .notNull()
    .references(() => user.id, { onDelete: "cascade" }),
  message: text("message").notNull(),
  isInternal: boolean("is_internal").default(false).notNull(), // admin-only notes
  createdAt: timestamp("created_at", { withTimezone: true })
    .defaultNow()
    .notNull(),
});

// Application logs
export const appLog = pgTable("app_log", {
  id: serial("id").primaryKey(),
  level: logLevelEnum("level").default("info").notNull(),
  message: text("message").notNull(),
  context: text("context"), // JSON string with additional context
  userId: text("user_id").references(() => user.id, { onDelete: "set null" }), // optional user context
  correlationId: text("correlation_id"), // for distributed tracing
  createdAt: timestamp("created_at", { withTimezone: true })
    .defaultNow()
    .notNull(),
});

// Database backups metadata
export const dbBackup = pgTable("db_backup", {
  id: serial("id").primaryKey(),
  filename: text("filename").notNull().unique(),
  fileSize: integer("file_size").notNull(), // in bytes
  createdByAdminId: text("created_by_admin_id")
    .notNull()
    .references(() => user.id, { onDelete: "cascade" }),
  description: text("description"),
  createdAt: timestamp("created_at", { withTimezone: true })
    .defaultNow()
    .notNull(),
});

// Step-up authentication tokens (for sensitive operations like role changes)
export const stepUpToken = pgTable("step_up_token", {
  id: serial("id").primaryKey(),
  token: text("token").notNull().unique(),
  userId: text("user_id")
    .notNull()
    .references(() => user.id, { onDelete: "cascade" }),
  expiresAt: timestamp("expires_at", { withTimezone: true }).notNull(), // TTL: 10 minutes
  used: boolean("used").default(false).notNull(), // one-time use
  createdAt: timestamp("created_at", { withTimezone: true })
    .defaultNow()
    .notNull(),
});

// Audit log for sensitive operations (role changes, admin actions, etc.)
export const auditLog = pgTable("audit_log", {
  id: serial("id").primaryKey(),
  userId: text("user_id")
    .notNull()
    .references(() => user.id, { onDelete: "cascade" }),
  action: text("action").notNull(), // e.g., 'CHANGE_ROLE', 'DELETE_USER', 'STEP_UP_AUTH'
  targetUserId: text("target_user_id").references(() => user.id, {
    onDelete: "set null",
  }), // user affected by the action
  metadata: text("metadata"), // JSON string with additional details (oldRole, newRole, etc.)
  ipAddress: text("ip_address"),
  userAgent: text("user_agent"),
  correlationId: text("correlation_id"), // for distributed tracing
  createdAt: timestamp("created_at", { withTimezone: true })
    .defaultNow()
    .notNull(),
});

// Account actions rate limiting (1x per day for password, email, username changes)
export const accountAction = pgTable("account_action", {
  id: serial("id").primaryKey(),
  userId: text("user_id")
    .notNull()
    .references(() => user.id, { onDelete: "cascade" }),
  action: text("action").notNull(), // 'CHANGE_PASSWORD', 'CHANGE_EMAIL', 'CHANGE_USERNAME'
  lastActionAt: timestamp("last_action_at", { withTimezone: true })
    .defaultNow()
    .notNull(),
  createdAt: timestamp("created_at", { withTimezone: true })
    .defaultNow()
    .notNull(),
});

/**
 * Menu PDF Ingestion & Review System
 */

// Menu parse batches - tracks PDF upload and parsing lifecycle
export const menuParseBatch = pgTable("menu_parse_batch", {
  id: serial("id").primaryKey(),
  uploadedByAdminId: text("uploaded_by_admin_id")
    .notNull()
    .references(() => user.id, { onDelete: "cascade" }),
  filename: text("filename").notNull(),
  fileHash: text("file_hash").notNull().unique(), // SHA-256 hash for deduplication
  fileSize: integer("file_size").notNull(), // in bytes
  filePath: text("file_path").notNull(), // storage path
  status: menuParseBatchStatusEnum("status").default("UPLOADED").notNull(),
  isTextNative: boolean("is_text_native"), // true = text PDF, false = scanned/OCR needed
  parseLog: text("parse_log"), // JSON string with parsing details
  errorMessage: text("error_message"), // error details if parse failed
  restaurantId: integer("restaurant_id").references(() => restaurant.id, {
    onDelete: "set null",
  }), // assigned restaurant (can be set during review)
  approvedByAdminId: text("approved_by_admin_id").references(() => user.id, {
    onDelete: "set null",
  }),
  approvedAt: timestamp("approved_at", { withTimezone: true }),
  publishedAt: timestamp("published_at", { withTimezone: true }),
  rejectedByAdminId: text("rejected_by_admin_id").references(() => user.id, {
    onDelete: "set null",
  }),
  rejectedAt: timestamp("rejected_at", { withTimezone: true }),
  rejectionReason: text("rejection_reason"),
  createdAt: timestamp("created_at", { withTimezone: true })
    .defaultNow()
    .notNull(),
  updatedAt: timestamp("updated_at", { withTimezone: true })
    .defaultNow()
    .$onUpdate(() => new Date())
    .notNull(),
});

// Menu parse items - staging area for parsed dishes before approval
export const menuParseItem = pgTable("menu_parse_item", {
  id: serial("id").primaryKey(),
  batchId: integer("batch_id")
    .notNull()
    .references(() => menuParseBatch.id, { onDelete: "cascade" }),
  dishName: text("dish_name").notNull(),
  dishNameNormalized: text("dish_name_normalized").notNull(), // normalized for matching
  description: text("description"),
  priceEur: numeric("price_eur", { precision: 10, scale: 2 }).notNull(), // parsed price in EUR
  priceConfidence: numeric("price_confidence", { precision: 3, scale: 2 }), // 0.00-1.00 confidence score
  category: text("category"), // detected category (e.g., "Hauptgerichte", "GetrÃ¤nke")
  options: text("options"), // JSON string for variants/sizes
  pageNumber: integer("page_number"), // source page in PDF
  boundingBox: text("bounding_box"), // JSON string with coordinates {x, y, width, height}
  rawText: text("raw_text"), // original extracted text for this item
  action: menuParseItemActionEnum("action").default("PENDING").notNull(),
  editedData: text("edited_data"), // JSON string with manual edits during review
  existingMenuItemId: integer("existing_menu_item_id").references(
    () => menuItem.id,
    { onDelete: "set null" },
  ), // matched existing dish for diff
  createdAt: timestamp("created_at", { withTimezone: true })
    .defaultNow()
    .notNull(),
  updatedAt: timestamp("updated_at", { withTimezone: true })
    .defaultNow()
    .$onUpdate(() => new Date())
    .notNull(),
});

// Dish versions - track changes to published dishes
export const dishVersion = pgTable("dish_version", {
  id: serial("id").primaryKey(),
  menuItemId: integer("menu_item_id")
    .notNull()
    .references(() => menuItem.id, { onDelete: "cascade" }),
  dishName: text("dish_name").notNull(),
  description: text("description"),
  price: numeric("price", { precision: 10, scale: 2 }).notNull(),
  category: text("category").notNull(),
  type: text("type").notNull(), // stored as text for history
  changedByAdminId: text("changed_by_admin_id")
    .notNull()
    .references(() => user.id, { onDelete: "cascade" }),
  changeReason: text("change_reason"),
  createdAt: timestamp("created_at", { withTimezone: true })
    .defaultNow()
    .notNull(),
});
